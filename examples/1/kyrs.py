from sympy import randprime, primitive_root  # Импорт модуля для работы с простыми числами
from random import randint  # Импорт модуля для работы со случаными числами
import time  # Импорт модуля для засечки времени шифрования
import codecs

ROUNDS_COUNT_X4 = 16  # Константа разделения ключа


# Функция генерации ключей для Схемы Эль-Гамаля
def generate_key(open_keys_file, close_key_file):
    p = randprime(2 ** 19, (2 ** 20) - 1)  # Генерируем прострое 16-битное число
    g = primitive_root(p)  # Находим первообразную
    print('Параметры: \np =', p, '\ng =', g)
    close_key = randprime(2, p - 1)  # Генерируем секретный "закрытый ключ"
    y = (g ** close_key) % p  # Вычисляем "открытый ключ"
    open_keys = [p, g, y]  # упаковывем от открытый ключ и параметры в список
    print('Открытый ключ y =', y, '\nЗакрытый ключ x =', close_key, )
    with codecs.open(open_keys_file, 'w', encoding='utf8') as file:  # Открываем файл на чтение
        for key in open_keys:
            file.write(str(key) + '\n', )  # Построчно записываем открытый ключ и параметры
    with codecs.open(close_key_file, 'w', encoding='utf8') as file:
        file.write(str(close_key))  # Записываем "закрытый ключ" в другой файл


# Функция шифрования Схемы Эль-Гамаля
def to_crypt_el_gamal(input_file, open_keys, output_file):
    M = ''
    with codecs.open(input_file, 'r', encoding='utf8') as file:
        for s in file.readline():  # Присваиваем переменной М сообщение из файла
            # Меры, чтобы исключить "ошибки" при кодировании cp1241 и utf8 в Windows
            try:
                if isinstance(int(ord(s)), int):
                    M += s
            except Exception:
                continue
    # Присваиваем открытый ключ
    with codecs.open(open_keys, 'r', encoding='utf8') as file:
        p = int(file.readline())
        g = int(file.readline())
        y = int(file.readline())

    # Проверяем, чтобы сообщение было больше параметра p, иначе вызываем исключение
    # if M > p:
    #     raise Exception('Внимание! Ошибка: M > p ! Сгенерируйте новую пару ключей или измените открытый текст')
    b = ''
    print('Открытый текст M =', M)
    k = randint(2, p - 1)
    a = (g ** k) % p  # Вычисляем первую часть шифротекста
    print('Шифротекст:')
    print('a =', a)
    for m in M:
        delta = ((y ** k) * ord(m)) % p  # Вычисляем вторую часть шифротекста
        b += chr(delta)
    print('b =', b)
    cipher = (a, b)  # Упаковываем шифротекст в кортеж
    with codecs.open(output_file, 'w', encoding='utf8') as file:
        for arg in cipher:
            file.write(str(arg) + '\n')  # Записываем шифротекст в файл


# Функция расшифрования по Схеме Эль-Гамаля
def to_decrypt_el_gamal(cipher_file, open_keys, close_key, output_file):
    B = ''
    M = ''
    with codecs.open(cipher_file, 'r', encoding='utf8') as file:
        a = int(file.readline())
        for s in file.readline():  # Присваиваем переменной М сообщение из файла
            # Меры, чтобы исключить "ошибки" при кодировании cp1241 и utf8 в Windows
            try:
                if isinstance(int(ord(s)), int):
                    B += s
            except Exception:
                continue
    with codecs.open(open_keys, 'r', encoding='utf8') as file:
        p = int(file.readline())
    with codecs.open(close_key, 'r', encoding='utf8') as file:
        x = int(file.readline())
    for b in B:
        delta = ord(b) * a ** (p - 1 - x) % p  # Расшифроваем сообщение
        M += chr(delta)
    M = M[0:-1]
    print('Открытый текст M =', M)

    with codecs.open(output_file, 'w', encoding='utf8') as file:
        file.write(str(M))


# Генерация симметричного ключа с разрядностью 128 бит
def generate_symmetric_key(close_key_file):
    with codecs.open(close_key_file, 'w', encoding='utf8') as file:
        close_key = randint(2 ** 127, (2 ** 128) - 1)  # Генерируем секретный ключ в диапазоне всех 128 битных чисел
        file.write(str(close_key))  # Записываем в файл
# Схема с линейно-рекурентным регистром
def text_to_bits( text, encoding= "utf-8", errors= "surrogatepass"):
    # Thanks jfs - convert-binary-to-ascii-and-vice-versa
    bits = bin(int.from_bytes( text.encode(encoding, errors), "big")) [ 2:]
    return bits.zfill(8  * ((len(bits) +  7 ) // 8))


def text_from_bits( bits, encoding= "utf-8", errors= "ignore"):
    # Thanks jfs - convert-binary-to-ascii-and-vice-versa
    n =  int(bits, 2)
    return n.to_bytes(
 (n.bit_length() +  7 ) //  8 , "big").decode(encoding, errors) or '\0'


def LFSR(text_bin: object, key: object, poly: object, lfsr: object) -> object:
    # The lfsr is generated by the key and polynomial
    for digit in text_bin:
        xor =  sum(key[ num] for num in poly)
        xor =  0  if xor %  2  ==  0  else 1
        lfsr.append( xor)
        key.insert( 0, xor)
        del key[-1]
    return lfsr


def FullAdder( text_bin, lfsr_17, lfsr_25, cin, crypt_bin):
    # This is the standard full-adder truth table
    for i, digit in enumerate(text_bin):
        lsfr_cin_sum = lfsr_17[i] + lfsr_25[i] + cin
        s =  0  if lsfr_cin_sum ==  0  or lsfr_cin_sum ==  2  else 1
        cout =  0  if lsfr_cin_sum ==  0  or lsfr_cin_sum ==  1  else 1
        crypt_bin.append((s +  digit) %  2)
        cin = cout
    return crypt_bin


### Import file
with open('plain_text.txt', 'r') as f:
    plaintext = f.read()
f.close()

### Plaintext
plaintext_bin =  list(map(int, text_to_bits(plaintext)))

### Keyword
keyword = "81936999765"
keyword_bin =  text_to_bits( keyword)

### Keys
key_17 =  list( map(int, '1'  +  keyword_bin[: 16]))
key_25 =  list( map(int, '1'  +  keyword_bin[ 16:]))

### LFSR Plaintext
lfsr_17 =  LFSR( plaintext_bin, key_17, ( 16, 2), [])
lfsr_25 = LFSR(plaintext_bin, key_25, (24, 7, 5, 1), [])

### Full Adder Plaintext
ciphertext_bin =  FullAdder( plaintext_bin, lfsr_17, lfsr_25, 0, [])

### Output Ciphertext
ciphertext =  text_from_bits("".join( map(str, ciphertext_bin)))

### Full Adder Ciphertext
dectext_bin =  FullAdder( ciphertext_bin, lfsr_17, lfsr_25, 0, [])

### Output Dectext
dectext = text_from_bits("".join( map(str, dectext_bin)))

### Print the results
print("The keyword: ", keyword)
print("\nThe plaintext: ", plaintext[3:])
print("\nThe ciphertext: ", ciphertext)
print("\nThe dectext: ", dectext[3:])

if __name__ == '__main__':
    # Списко местоположения файлов
    open_keys_filename = 'open_keys.txt'
    close_key_filename = 'close_key.txt'
    plain_text_filename = 'plain_text.txt'
    cipher_text_filename = 'cipher_text.txt'

    # Менюшка для вызова функций
    while True:
        choice = input("""
        Выберите алгоритм шифрования:

        1. Схема Эль-Гамаля
        2. Схема с линейно-рекурентым регистром

        ----Выход (Эникей) ----
        """)
        if int(choice) == 1:
            while True:
                next_choice = input("""
                Выберите действие (Схема Эль-Гамаля):
                1) Сгенерировать пару ключей
                2) Зашифровать сообщение
                3) Расшифорвать сообщение
                4) <--- назад (к выбору алгоритма)
                """)
                if int(next_choice) == 1:
                    generate_key(open_keys_filename, close_key_filename)
                    print('Новая пара ключей сгенерирована!')
                    continue
                elif int(next_choice) == 2:
                    started_at = time.time()  # Ставим 1ую отсечку времени
                    to_crypt_el_gamal(plain_text_filename, open_keys_filename, cipher_text_filename)
                    ended_at = time.time()  # Ставим 2ую отсечку
                    elapsed = round(ended_at - started_at, 4)  # 2ая отсечка минус 1ая - получаем время работы функции
                    print(f'Шифрование продолжалось {elapsed} секунд(ы)')
                    print('Сообщение зашифровано!')
                elif int(next_choice) == 3:
                    started_at = time.time()  # Ставим 1ую отсечку времени
                    to_decrypt_el_gamal(cipher_text_filename, open_keys_filename, close_key_filename,
                                        plain_text_filename)
                    ended_at = time.time()  # Ставим 2ую отсечку
                    elapsed = round(ended_at - started_at, 4)  # 2ая отсечка минус 1ая - получаем время работы функции
                    print(f'Расшифровка продолжалось {elapsed} секунд(ы)')
                    print('Сообщение расшифровано!')
                else:
                    break
        elif int(choice) == 2:
            while True:
                next_choice = input("""
                                Выберите действие (Схема с линейно-рекурентым регистром):
                                1) Сгенерировать симметричный ключ
                                2) Зашифровать сообщение
                                3) Расшифорвать сообщение
                                4) <--- назад (к выбору алгоритма)
                                """)
                if int(next_choice) == 1:
                    generate_symmetric_key(close_key_filename)
                    print('Сииметричный ключ сгенерирован!')
                    continue
                elif int(next_choice) == 2:
                    started_at = time.time()
                    ciphertext_bin =  FullAdder( plaintext_bin, lfsr_17, lfsr_25, 0, [])
                    ciphertext =  text_from_bits("".join( map(str, ciphertext_bin)))
                    print(ciphertext)

                    ended_at = time.time()
                    elapsed = round(ended_at - started_at, 4)
                    print(f'Шифрование продолжалось {elapsed} секунд(ы)')
                    print('Сообщение зашифровано!')
                elif int(next_choice) == 3:
                    started_at = time.time()

                    dectext_bin =  FullAdder( ciphertext_bin, lfsr_17, lfsr_25, 0, [])
                    dectext = text_from_bits("".join( map(str, dectext_bin)))
                    print(dectext)

                    ended_at = time.time()
                    elapsed = round(ended_at - started_at, 4)
                    print('Сообщение расшифровано!')
                else:
                    break
        else:
            print('Сворачиваемся!')
            break
